/*
====================== ZOD ERROR BEHAVIOUR (FRONTEND vs BACKEND) ======================
 
Frontend me error direct simple format me kyun milta hai?

React Hook Form + Zod Resolver internally ye steps karta hai:

1) Zod schema se validation run hota hai
2) Agar error aata hai to ZodError milta hai (raw form me)
3) zodResolver us raw error ko read karta hai (err.issues)
4) Usko convert karke React Hook Form ke format me daal deta hai

Isliye frontend me hume directly milta hai:

errors.userName.message

Hume kabhi manually:
err.issues[0].message

likhne ki zarurat nahi padti.

Kyuki resolver already raw ZodError ko clean aur field-wise error object me convert kar deta hai.


- Backend me problem kyun aati hai?

Backend me hum direct Zod use karte hain:

userSchema.parse(req.body)

Agar validation fail hua to Zod khud ek raw error throw karta hai:

ZodError {
  issues: [
    {
      path: ["userName"],
      message: "Minimum 3 character required!"
    }
  ]
}

Yahan koi resolver nahi hota jo error ko clean kare.

Isliye backend me hume manually error read karna padta hai:

err.issues[0].message


 Simple comparison

- Frontend:
React Hook Form + zodResolver error ko already process karke deta hai:

errors.userName.message

- Backend:
Direct Zod use ho raha hai, isliye raw structure milta hai:

err.issues[0].message

Ek line me main difference:

Frontend:
React Hook Form + zodResolver → error ko simple bana deta hai

Backend:
Direct Zod use → raw error structure milta hai


- Real life example samjho:

Backend = Raw milk 
Frontend = Tea 

Milk ko boil + mix karke chai banayi jaati hai.

Waise hi:

ZodError (raw)
        ↓
zodResolver process karta hai
        ↓
errors.userName.message (ready-made)


 Interview level understanding (Important)

"Frontend me err.issues kyun nahi use karte?"

Answer:

Kyuki React Hook Form ka zodResolver internally ZodError ko transform karke
field-wise error object bana deta hai.


 Important observation

Frontend me:
Simple processed error milta hai

Backend me:
Raw Zod error milta hai

Dono me same Zod use ho raha hai,
bas handling ka tareeka alag hai.


 Best backend practice (clean response dene ke liye):

catch (err) {
  return res.status(400).json({
    type: err.issues?.[0]?.path?.[0],
    message: err.issues?.[0]?.message
  });
}

Isse response milega:

{
  "type": "userName",
  "message": "Minimum 3 character required!"
}

Jo bilkul frontend jaisa readable format hai.
*/
==========================================================
/*
====================== ZOD ERROR NOTES (For Future Learning) ======================

- Zod validation fail hone par ek special error object milta hai:
   → Iska naam hota hai: ZodError

- ZodError ka structure kuch aisa hota hai:

   err = {
     issues: [
       {
         origin: "string",
         code: "too_small",
         minimum: 3,
         inclusive: true,
         path: ["userName"],
         message: "Minimum 3 character required!"
       }
     ]
   }

 - Important Point:
   ❌ err.errors   → Old/incorrect reference (kabhi undefined mil sakta hai)
   ✅ err.issues   → Correct property (Zod v3+)

- First error message nikalne ka sahi tarika:

   err.issues[0].message

- Safe access (best practice):

   err.issues?.[0]?.message

   Ye crash hone se bachata hai agar issues empty ho.

- err.message kya deta hai?

   → err.message actually pura issues array ko STRING bana deta hai.
   Example:
   "[ { message: 'Minimum 3 character required!' } ]"

   Isliye:
   err.message → debugging ke liye thik hai
   err.issues  → production use ke liye best hai

 - Agar kabhi err.message ko array me convert karna ho:

   const errorsArray = JSON.parse(err.message);

   errorsArray[0].message

   ⚠️ But ye recommended approach nahi hai.
   Direct err.issues use karna better hai.

   Summary (Most Correct Way):

   catch (err) {
     return res.status(400).json({
       type: "userName",
       message: err.issues?.[0]?.message
     });
   }

===============================================================================
*/

